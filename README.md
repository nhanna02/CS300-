# CS300-
The course aimed to address the challenge of establishing effective methods for storing, organizing, and retrieving Computer Science program course data. Through Project One I assessed different data structures to evaluate their runtime and memory consumption which helped me choose the best option for handling course data. I created functional C plus plus code in Project Two that reads course data and stores it using suitable data structures while sorting and displaying courses in alphanumeric sequence. The main goal of the project involved studying how different algorithms and data structures influence system performance and extension capabilities and user accessibility.

The solution process began with me testing three standard data structures which included vectors and hash tables and binary search trees to measure their performance through testing basic operations like insertion and search and traversal functions. My ability to assess performance tradeoffs depended on my understanding of Big O notation which served as my primary performance measurement system. Balanced tree operations execute balanced tree operations at a speed that matches logarithmic time while basic linear searches function at a consistent speed that matches linear time. The distinction between these elements enabled me to explain my design choices which resulted in selecting a system that could execute efficient sorted output and fast data retrieval. The field of software development relies on knowledge of data structures because this knowledge determines how software behaves when data volume increases.

During the projects I faced difficulties with pointer logic and tree traversal methods and the accurate implementation of sorting functions. I solved these problems through component breakdown which allowed me to test each function separately while monitoring the program's functions through its execution process. The combination of debugging tools and variable testing allowed me to identify logical mistakes which resulted in enhanced system dependability.The combination of debugging tools together with incremental testing methods enabled me to find and fix logic errors while enhancing the system's overall dependability. The experiences I had with these situations developed my ability to solve problems and increased my confidence in using systematic methods to find faults instead of depending on random testing methods.

My software design approach changed forever when I started working on these projects because they taught me to look for solutions that went beyond basic program functionality. I started to view efficiency together with scalability and maintainability as essential design elements instead of treating them as optional enhancements. I learned to separate logic into modular functions, use meaningful variable names, and structure code for readability. The changes I made to my programming style resulted in programs which now have better organization and simpler maintenance tasks because they can be updated without any difficulties. The work demonstrates my knowledge of data structures and algorithms together with my ability to create efficient solutions and my progress in developing clean and maintainable code which performs well.
